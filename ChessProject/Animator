package animator;
        
import java.awt.AlphaComposite;
import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Cursor;
import java.awt.Dimension;
import java.awt.Font;
import java.awt.FontMetrics;
import java.awt.Frame;
import java.awt.Graphics;
import java.awt.Graphics2D;
import java.awt.GraphicsEnvironment;
import java.awt.Insets;
import java.awt.MouseInfo;
import java.awt.Point;
import java.awt.Rectangle;
import java.awt.Robot;
import java.awt.Toolkit;
import java.awt.event.KeyAdapter;
import java.awt.event.KeyEvent;
import java.awt.event.KeyListener;
import java.awt.event.MouseEvent;
import java.awt.event.MouseListener;
import java.awt.event.MouseMotionListener;
import java.awt.event.MouseWheelEvent;
import java.awt.event.MouseWheelListener;
import java.awt.geom.AffineTransform;
import java.awt.image.BufferedImage;
import java.awt.image.ColorModel;
import java.awt.image.WritableRaster;
import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileWriter;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.io.Writer;
import java.lang.reflect.Method;
import java.text.DateFormat;
import java.text.SimpleDateFormat;
import java.util.ArrayList;
import java.util.Date;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import javax.imageio.ImageIO;
import javax.swing.JFrame;
import javax.swing.JPanel;
import javax.swing.JTextArea;
import javax.swing.SwingUtilities;

public class Animator extends Din {
    public static Animator o;
    public int width, height;
    private boolean empty, shadow = false;
    public BufferedImage image, shadow_image, prev_image, helper_image;
    public Graphics2D graphics, shadow_graphics;
    public JFrame frame;
    public DrawPanel drawPanel;
    public KL kl;
    public ML ml;
    public MWL mwl;
    public MML mml;
    public int cursorNum = 888;
    private long milisecs, last_input_milisecs;
    public double frame_time, total_time;
    public int frame_counter = 0;
    public Map<Integer, Integer> keys, mice;
    public Set<Integer> nokeys;
    public int notches, keyless;
    public Point mouse_point, typed_point, center;
    private int dx, dy;
    public boolean pause, only_minipause, one_step;
    public Object myclass;
    public String[] modes;
    private boolean animating = false;
    public boolean fin = false;
    public boolean mode_found = true;
    public int mode;
    public boolean decorated, retitle;
    public boolean showmessage = true;
    public boolean mouse3pop = true;
    public Robot robot;
    public boolean robotnic;
    public String active;
    public Poper poperMaster;
    public JTextArea textArea;
    public String text;
    public boolean text_enter = false, tab_enter = false, rtab_enter = false;
    public boolean multi_entered = false;
    int fadeNumber, fadeCounter;
    double fadeFactor, fadeMult;
    
    public static final int ROBOT_WAIT = 100;
    public static final double RATE_FACTOR = 0.03;
     
    public Animator(Object myclass_, int width_, int height_, String playlist_,
            boolean decorated_) {
        super(myclass_.getClass());
        o = this;
        myclass = myclass_;
        playlist_ = playlist_.replace(" ", "");
        empty = playlist_.isEmpty();
        modes = playlist_.split(",");
        mode = -1;
        frame = new JFrame();
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        drawPanel = new DrawPanel();
        CreateListen();
        FrameListen();
        frame.getContentPane().add(BorderLayout.CENTER, drawPanel);
        decorated = decorated_;
        frame.setUndecorated(!decorated);
        if (decorated) {
            Dimension screenSize = Toolkit.getDefaultToolkit().getScreenSize();
            width = screenSize.width;
            height = screenSize.height;
        } else {
            GraphicsEnvironment.getLocalGraphicsEnvironment().
                    getDefaultScreenDevice().setFullScreenWindow(frame);
            width = frame.getWidth();
            height = frame.getHeight();
        }
        if (width_ > 0 && width_ < width) width = width_;
        if (height_ > 0 && height_ < height ) height = height_;
        frame.setSize(width, height);
        frame.setState(Frame.NORMAL);
        frame.setResizable(false);
        image = new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        graphics = image.createGraphics();
        shadow_image =
                new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        prev_image =
                new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        helper_image =
                new BufferedImage(width, height, BufferedImage.TYPE_INT_ARGB);
        shadow_graphics = shadow_image.createGraphics();
        keys = new TreeMap<>();
        mice = new TreeMap<>();
        keyless = 0;
        SetKey(KeyEvent.VK_ENTER);
        nokeys = new TreeSet<>();
        drawPanel.setLayout(null);
        SetCursor(-1);
        frame.setVisible(true);
        frame_time = 0.005;
        Robotnic();
    }
    
    public static void Exit(Exception ex) {
        ex.printStackTrace();
        System.exit(8);
    }

    public void Animate() {
        if (!empty) frame.setVisible(true);
        boolean mac = System.getProperty("os.name").contains("Mac");
        if (mac) {
            try { Runtime.getRuntime().exec("defaults write NSGlobalDomain " +
                    "ApplePressAndHoldEnabled -bool false");
            } catch (Exception ex) { Exit(ex); }
        }
        animating = true;
        while (!fin) {
            frame.repaint();
            if (empty && Done("")) break;
        }
        frame.dispose();
        Quiet("");
        if (mac) {
            try { Runtime.getRuntime().exec("defaults write NSGlobalDomain " +
                    "ApplePressAndHoldEnabled -bool true");
            } catch (Exception ex) { Exit(ex); }
        }
    }

    public void AnimateStep() {
        frame.repaint();
        if (Typed(KeyEvent.VK_ESCAPE, true)) {
            frame.dispose();
            Quiet("");
        }
    }
    
    public String GetName() {
        return modes[mode];
    }
    
    public void SetCursor(int cursor) {
        if (cursor == cursorNum) return;
        cursorNum = cursor;
        if (cursor >= 0) {
            frame.getContentPane().setCursor(new Cursor(cursor));
        } else {
            BufferedImage cursorImg = new BufferedImage(1, 1,
                BufferedImage.TYPE_INT_ARGB);
            Cursor blankCursor = Toolkit.getDefaultToolkit().createCustomCursor(
                cursorImg, new Point(0, 0), "blank cursor");
            frame.getContentPane().setCursor(blankCursor);
        }
    }
    
    public void Robotnic() {
        if (robot == null) {
            try { robot = new Robot();
            } catch (Exception ex) { Exit(ex); }
        }
        robotnic = true;
        MouseMove(0, 0);
        try { Thread.sleep(2 * ROBOT_WAIT);
        } catch (InterruptedException ex) {}
        MouseMove(0, 0);
        try { Thread.sleep(ROBOT_WAIT);
        } catch (InterruptedException ex) {}
        Point point = MouseInfo.getPointerInfo().getLocation();
        int diff = Math.abs(point.x - dx) + Math.abs(point.y - dy);
        MouseMove(width * 3 / 4, height * 3 / 4);
        try { Thread.sleep(2 * ROBOT_WAIT);
        } catch (InterruptedException ex) {}
        MouseMove(width * 3 / 4, height * 3 / 4);
        try { Thread.sleep(ROBOT_WAIT);
        } catch (InterruptedException ex) {}
        point = MouseInfo.getPointerInfo().getLocation();
        diff += Math.abs(point.x - width * 3 / 4 - dx) +
                Math.abs(point.y - height * 3 / 4 - dy);
        robotnic =  diff < 0.1 * height;
    }
    
    public boolean Call(String str) {
        return Call(myclass, str);
    }
    
    public boolean Call(Object mc, String str) {
        Method method = null;
        try { method = mc.getClass().getDeclaredMethod(str,
                (Class<?>[])null);
        } catch (NoSuchMethodException ex) {
            return false;
        } catch (SecurityException ex) { Exit(ex); }
        method.setAccessible(true);
        try { method.invoke(mc);
        } catch (Exception ex) { Exit(ex); }
        return true;
    }

    public void MouseMove(int i, int j) {
        if (robot != null && robotnic) robot.mouseMove(i + dx, j + dy);
    }

    public void MouseCenter() {
        MouseMove(center.x, center.y);
    }
    
    public void RecomputeMousePoint() {
        Point mouse_point_0 = MouseInfo.getPointerInfo().getLocation();
        mouse_point = new Point(mouse_point_0.x - dx, mouse_point_0.y - dy);
    }
    
    public boolean PrePressed(int key) {
        int c = keys.getOrDefault(key, -1);
        if (c < 0) return false;
        keys.replace(key, c & 0xe);
        return (c & 1) != 0;
    }

    public boolean Pressed(int key) {
        int c = keys.getOrDefault(key, -1);
        if (c < 0) return false;
        return (c & 2) != 0;
    }
    
    public boolean Typed(int key) {
        return Typed(key, false);
    }
    
    public boolean Typed(int key, boolean inside) {
        if (inside && nokeys.contains(key)) return false;
        int c = keys.getOrDefault(key, -1);
        if (c < 0) return false;
        keys.replace(key, c & 0xb);
        return (c & 4) != 0;
    }
    
    public boolean MousePrePressed(int button) {
        int c = mice.getOrDefault(button, -1);
        if (c < 0) return false;
        mice.replace(button, c & 0xe);
        return (c & 1) != 0;
    }
    
    public boolean MousePressed(int button) {
        int c = mice.getOrDefault(button, -1);
        if (c < 0) return false;
        return (c & 2) != 0;
    }
    
    public boolean MouseTyped(int button) {
        int c = mice.getOrDefault(button, -1);
        if (c < 0) return false;
        mice.replace(button, c & 0xb);
        return (c & 4) != 0;
    }
    
    public int WheeledReset() {
        int n = notches;
        notches = 0;
        return n;
    }
    
    public static void SetAlpha(Graphics2D g, double alpha) {
        AlphaComposite alcom = AlphaComposite.getInstance(
                    AlphaComposite.SRC_OVER, (float)alpha);
        g.setComposite(alcom);
    }
    
    public void SetFade(double fadeFactor_, int fadeNumber_) {
        fadeFactor = fadeFactor_;
        fadeNumber = fadeNumber_;
        fadeMult = 1.;
        fadeCounter = 0;
    }
    
    public void Fade(Graphics2D g, BufferedImage fadeImage) {
        if (fadeNumber <= 0) return;
        ++fadeCounter;
        if (fadeCounter > fadeNumber) {
            fadeCounter = 0;
            fadeMult = Math.min(fadeFactor * fadeMult, fadeNumber);
        }
        if ((fadeCounter % (int)fadeMult) != 0) return;
        SetAlpha(g, fadeMult / fadeNumber);
        g.drawImage(fadeImage, 0, 0, null);
        SetAlpha(g, 1.);
        if (fadeMult >= fadeNumber) fadeNumber = 0;
    }
    
    public void Shadow() {
        shadow = true;
        shadow_graphics.drawImage(image, 0, 0, null);
    }
    
    public static String CFN(String path) {
        if (path == null) return null;
        if (File.separatorChar=='\\') {
            return path.replace('/', File.separatorChar);
        } else {
            return path.replace('\\', File.separatorChar);
        }
    }
    
    public BufferedImage ReadAndRescale(String path,
            double i_scale_x, double i_scale_y, int i_mode) {
        // i_mode = 0 - absolute, 1 - relative to image, 2 - relative to screen
        BufferedImage img = null;
        try {
            img = ImageIO.read(new File(CFN("src/" + path)));
        } catch (Exception ex) {}
        if (img == null) {
            try { img = ImageIO.read(new File(CFN(path)));
            } catch (Exception ex) {}
        }
        if (img == null) {
            Jar2File("/" + path, path);
            try { img = ImageIO.read(new File(CFN(path)));
            } catch (Exception ex) {}
        }
        if (img == null) {
            System.out.println("Failed reading image " + path);
            return null;
        }
        int imag_width, imag_height;
        if (i_mode == 0) {
            imag_width = (int) Math.abs(i_scale_x);
            imag_height = (int) Math.abs(i_scale_y);
        } else if (i_mode == 1) {
            imag_width = (int) (Math.abs(i_scale_x) * img.getWidth());
            imag_height = (int) (Math.abs(i_scale_y) * img.getHeight());
        } else {
            imag_width = (int) (Math.abs(i_scale_x) * width);
            imag_height = (int) (Math.abs(i_scale_y) * height);
        }
        BufferedImage imag;
        if ((imag_width == img.getWidth()) &&
                (imag_height == img.getHeight()) &&
                (i_scale_x > 0) && (i_scale_y > 0)) {
            imag = img;
        } else {
            AffineTransform at = new AffineTransform();
            at.scale(imag_width / (double)img.getWidth(),
                    imag_height / (double)img.getHeight());
            imag = new BufferedImage(imag_width, imag_height,
                    BufferedImage.TYPE_INT_ARGB);
            imag.createGraphics().drawImage(img, at, null);
            if ((i_scale_x < 0) || (i_scale_y < 0))
                imag = Flip(imag, i_scale_x < 0, i_scale_y < 0, false, false);
        }
        return imag;
    }
    
    public static BufferedImage Flip(BufferedImage image, boolean flip_x,
            boolean flip_y, boolean transpose, boolean inverse) {
        int w = image.getWidth();
        int h = image.getHeight();
        BufferedImage img;
        if (!transpose) {
            img = new BufferedImage(w, h, BufferedImage.TYPE_INT_ARGB);
            for (int j = 0; j < h; ++j) {
                int jj = flip_y? h - 1 - j : j;
                for (int i = 0; i < w; ++i) {
                    int ii = flip_x? w - 1 - i : i;
                    img.setRGB(ii, jj, image.getRGB(i, j));
                }
            }
        } else {
            img = new BufferedImage(h, w, BufferedImage.TYPE_INT_ARGB);
            if (inverse) {
                boolean help = flip_x;
                flip_x = flip_y;
                flip_y = help;
            }
            for (int j = 0; j < h; ++j) {
                int jj = flip_y? h - 1 - j : j;
                for (int i = 0; i < w; ++i) {
                    int ii = flip_x? w - 1 - i : i;
                    img.setRGB(jj, ii, image.getRGB(i, j));
                }
            }
        }
        return img;
    }
    
    public static BufferedImage Gemini(BufferedImage image) {
        int w = image.getWidth();
        int h = image.getHeight();
        BufferedImage img;
        img = new BufferedImage(w, 2 * h, BufferedImage.TYPE_INT_ARGB);
        for (int j = 0; j < h; ++j) {
            for (int i = 0; i < w; ++i) {
                int c = image.getRGB(i, j);
                img.setRGB(i, h - 1 - j, c);
                img.setRGB(i, h + j, c);
            }
        }
        return img;
    }
    
    public void Purify(String path, int col) {
        BufferedImage img = ReadAndRescale(path, 1., 1., 2);
        for (int j = 0; j < img.getHeight(); ++j) {
            for (int i = 0; i < img.getWidth(); ++i) {
                if (img.getRGB(i, j) != col) {
                    img.setRGB(i, j, 0);
                }
            }
        }
        File outputfile = new File(path);
        try { ImageIO.write(img, "png", outputfile);
        } catch (IOException ex) {}
    }
    
    public class DrawPanel extends JPanel {
        private static final long serialVersionUID = 1L;
        
        @Override
        public void paintComponent(Graphics g) {
            if (!animating) return;
            long ms = System.currentTimeMillis();
            ++frame_counter;
            Point mouse_point_0 = MouseInfo.getPointerInfo().getLocation();
            mouse_point = (Point)mouse_point_0.clone();
            SwingUtilities.convertPointFromScreen(mouse_point, this);
            dx = mouse_point_0.x - mouse_point.x;
            dy = mouse_point_0.y - mouse_point.y;
            Insets insets = frame.getInsets();
            center = new Point((width - insets.right + insets.left) / 2,
                    (height - insets.top + insets.bottom) / 2);
            one_step = false;
            boolean pren = Typed(KeyEvent.VK_ENTER, true);
            boolean prqu = Typed(KeyEvent.VK_QUOTE, true);
            if (Typed(KeyEvent.VK_ESCAPE, true)) {
                fin = true;
            } else if (Typed(KeyEvent.VK_F2, true)) {
                try {
                    DateFormat dateFormat =
                            new SimpleDateFormat("yyyy_MM_dd__HH_mm_ss");
                    String fname = System.getProperty("user.home") +
                            "/Downloads/screen_" +
                            dateFormat.format(new Date());
                    File f = new File(CFN(fname));
                    ImageIO.write(image, "png", f);
                    System.out.println("Screen saved at " + fname);
                } catch(Exception ex) { Exit(ex); }
            } else if (Typed(KeyEvent.VK_BACK_SPACE, true) || pren || prqu) {
                if (pren)
                    mode = (mode + 1) % modes.length;
                if (prqu)
                    mode = (mode + modes.length - 1) % modes.length;
                pause = false;
                Quiet("");
                keys.clear();
                mice.clear();
                boolean init_found = Call("Init_"  + modes[mode]);
                if (!init_found) Call("Init_");
                boolean background_found = Call("Background_" + modes[mode]);
                if (!background_found) Call("Background_");
                mode_found = init_found || background_found;
                shadow = false;
            } else if (Typed(KeyEvent.VK_B, true)) {
                boolean background_found = Call("Background_" + modes[mode]);
                if (!background_found) Call("Background_");
            } else if (Typed(KeyEvent.VK_SHIFT, true)) {
                one_step = true;
                pause = !pause;
            } else if (Typed(KeyEvent.VK_SPACE, true)) {
                pause = !pause;
            } else if (Typed(KeyEvent.VK_SLASH, true)) {
                helper_image.createGraphics().drawImage(image, 0, 0, null);
                graphics.drawImage(prev_image, 0, 0, null);
                prev_image.createGraphics().drawImage(helper_image, 0, 0, null);
                one_step = pause = true;
            }
            if (!pause || only_minipause) {
                if (one_step)
                    prev_image.createGraphics().drawImage(image, 0, 0, null);
                if (retitle) frame.setTitle(modes[mode]);
                boolean foreground_found = Call("Foreground_" + modes[mode]);
                if (!foreground_found) Call("Foreground_");
                mode_found |= foreground_found;
                if (!mode_found) {
                    System.out.println("mode " + modes[mode] + " not found");
                    System.exit(1);
                }
                if (frame.isActive()) {
                    if ((milisecs > 0) && (frame_counter > 2)) {
                        double dt = 0.001 * (ms - milisecs);
                        frame_time = Math.max(Math.min(dt, 1.5 * frame_time),
                                0.7 * frame_time);
                        if (!pause && frame.isActive())
                            total_time += frame_time;
                    }
                }
            } else {
                if (ms > last_input_milisecs + 2000) {
                    try { Thread.sleep(500);
                    } catch (InterruptedException ex) {}
                }
            }
            if (one_step) pause = true;
            boolean mouse3 = MouseTyped(3);
            if (mouse3pop) {
                if (mouse3 && poperMaster == null) {
                    MakePoper();
                } else if (poperMaster != null) {
                    poperMaster.Pop();
                    PoperAction();
                    if (mouse3 || poperMaster.activated) {
                        frame.getContentPane().setCursor(poperMaster.cursor);
                        poperMaster = null;
                        MouseCenter();
                    }
                }
            }
            g.drawImage(image, 0, 0, null);
            if (shadow) {
                shadow = false;
                graphics.drawImage(shadow_image, 0, 0, null);
            }
            if (retitle && !decorated) {
                Font oldFont = g.getFont();
                g.setFont(new Font("Dialog", Font.BOLD, 14));
                String str = modes[mode];
                int w = g.getFontMetrics().stringWidth(str);
                int h = g.getFontMetrics().getHeight();
                g.setColor(new Color(196, 196, 196, 128));
                g.fillRect((width - w - h / 2) / 2, 0, w + h / 2, h);
                g.setColor(Color.black);
                g.drawString(str, (width - w) / 2, h * 3 / 4);
                g.setFont(oldFont);
            }
            if (textArea != null) text = textArea.getText();
            milisecs = ms;
            if (keyless > 0) --keyless;
        }

    }
    
    void MakePoper() {
        poperMaster = new Poper("basePoper",
                new Rectangle(width / 2 - 200, -99, 400, 24));
        poperMaster.addPopItem("next mode  =  Return");
        poperMaster.addPopItem("previous mode  =  '");
        poperMaster.addPopItem("pause/unpause toggle  =  Space");
        poperMaster.addPopItem("step once  =  Shift");
        poperMaster.addPopItem("reverse/restore step once toggle  =  /");
        poperMaster.addPopItem("write screen  =  F2");
        poperMaster.addPopItem("exit  =  Esc");
    }
    
    public void SetKey(int key) {
        keys.put(key, 7);
    }
    
    public void PoperAction() {
        if (poperMaster == null) return;
        if (poperMaster.Check("next mode  =  Return"))
            SetKey(KeyEvent.VK_ENTER);
        if (poperMaster.Check("previous mode  =  '"))
            SetKey(KeyEvent.VK_QUOTE);
        if (poperMaster.Check("pause/unpause toggle  =  Space"))
            SetKey(KeyEvent.VK_BACK_SPACE);
        if (poperMaster.Check("step once  =  Shift"))
            SetKey(KeyEvent.VK_SHIFT);
        if (poperMaster.Check("reverse/restore step once toggle  =  /"))
            SetKey(KeyEvent.VK_SLASH);
        if (poperMaster.Check("write screen  =  F2"))
            SetKey(KeyEvent.VK_F2);
        if (poperMaster.Check("exit  =  Esc"))
            SetKey(KeyEvent.VK_ESCAPE);
    }
    
    public class KL implements KeyListener {

        @Override
        public void keyTyped(KeyEvent e) {}
        
        @Override
        public void keyPressed(KeyEvent e) {
            if (keyless > 0) return;
            int key = e.getExtendedKeyCode();
            keys.put(key, 3);
            last_input_milisecs = System.currentTimeMillis();
        }
        
        @Override
        public void keyReleased(KeyEvent e) {
            if (keyless > 0) return;
            int key = e.getExtendedKeyCode();
            keys.put(key, 4);
            last_input_milisecs = System.currentTimeMillis();
        }
        
    }
    
    public class ML implements MouseListener {

        @Override
        public void mouseClicked(MouseEvent e) {}
        
        @Override
        public void mousePressed(MouseEvent e) {
            typed_point = mouse_point;
            int mi = e.getButton();
            mice.put(mi, 3);
            last_input_milisecs = System.currentTimeMillis();
            if (mi == 3 && !showmessage) MakePoper();
        }
        
        @Override
        public void mouseReleased(MouseEvent e) {
            int mi = e.getButton();
            mice.put(mi, 4);
            last_input_milisecs = System.currentTimeMillis();
        }

        @Override
        public void mouseEntered(MouseEvent e) {}

        @Override
        public void mouseExited(MouseEvent e) {}
        
    }

    public class MWL implements MouseWheelListener {

        @Override
        public void mouseWheelMoved(MouseWheelEvent e) {
            last_input_milisecs = System.currentTimeMillis();
            notches = e.getWheelRotation();
        }
        
    }
    
    public class MML implements MouseMotionListener {

        @Override
        public void mouseDragged(MouseEvent e) {}

        @Override
        public void mouseMoved(MouseEvent e) {}
        
    }
    
    void CreateListen() {
        kl = new KL();
        ml = new ML();
        mwl = new MWL();
        mml = new MML();
    }
    
    void FrameListen() {
        frame.addKeyListener(kl);
        drawPanel.addMouseListener(ml);
        drawPanel.addMouseWheelListener(mwl);
        drawPanel.addMouseMotionListener(mml);
        frame.requestFocus();           
    }
    
    public class Poper {
        public String name;
        public Rectangle bounds;
        public ArrayList<Poper> slavePopers;
        public boolean activated;
        public double shineTime;
        public int popComulative;
        public Cursor cursor;
        
        public Poper(String name_, Rectangle bounds_) {
            name = name_;
            bounds = bounds_;
            active = "";
            slavePopers = new ArrayList<>();
            activated = false;
            shineTime = 0.;
            popComulative = 26;
            cursor = frame.getContentPane().getCursor();
        }
        
        public void addPopItem(String str) {
            if (str.equals("")) {
                popComulative += 10;
            } else {
                Animator.Poper pop = new Poper(str, new Rectangle(
                        bounds.x, popComulative, bounds.width, bounds.height));
                popComulative += bounds.height + 2;
                slavePopers.add(pop);
            }
        }
        
        public boolean Check(String nam) {
            if (active.equals(nam)) {
                active = "";
                return true;
            }
            return false;
        }
        
        public void Pop() {
            Pop(graphics);
        }

        public void Pop(Graphics g) {
            Color col = (total_time > shineTime)?
                    new Color(210, 210, 210, 196) :
                    new Color(210, 210, 0, 196);
            g.setColor(col);
            g.fillRect(bounds.x, bounds.y, bounds.width, bounds.height);
            Font oldFont = g.getFont();
            g.setFont(new Font("Dialog", Font.BOLD, 14));
            g.setColor(Color.black);
            g.drawString(name, bounds.x + 10, bounds.y + bounds.height / 2 + 4);
            g.setFont(oldFont);
            if (bounds.contains(typed_point == null? mouse_point : typed_point)
                    && MouseTyped(1)) {
                active = name;
                activated = true;
                shineTime = total_time + 0.67;
            }
            for (Poper p : slavePopers) {
                p.Pop(g);
                activated = activated || p.activated;
            }
            if (frame.getContentPane().getCursor() != Cursor.getDefaultCursor())
                frame.getContentPane().setCursor(Cursor.getDefaultCursor());
        }
    }
    
    public class MasterSlider {
        public String name;
        public Rectangle boundso, bounds;
        public double min_rate, rate, max_rate;
        public boolean mark, follow;
        public boolean slippery;
        public int morph;
        public double timer;
        public double vchange;
        public ArrayList<MultiSlider> lonerSliders;
        public ArrayList<MultiSlider> slaveSliders;
        public int mark_w = 80;
        
        public MasterSlider(String name_, Rectangle bounds_,
                double min_rate_, double max_rate_) {
            name = name_;
            boundso = bounds_;
            vchange = min_rate = min_rate_;
            max_rate = max_rate_;
            follow = true;
            slippery = false;
            active = "";
            lonerSliders = new ArrayList<>();
            slaveSliders = new ArrayList<>();
        }

        public void Slide(double zoom) {
            morph = 0;
            bounds = new Rectangle(boundso.x, boundso.y,
                    boundso.width, boundso.height);
            Graphics2D g = graphics;
            g.setColor(new Color(210, 210, 0, 196));
            g.fillRect(bounds.x, bounds.y, mark_w / 4, bounds.height);
            g.setColor(new Color(0, 210, 210, 196));
            g.fillRect(bounds.x + mark_w / 4, bounds.y,
                    mark_w / 4, bounds.height / 2);
            g.setColor(new Color(210, 0, 210, 196));
            g.fillRect(bounds.x + mark_w / 4, bounds.y + bounds.height / 2,
                    mark_w / 4, bounds.height / 2);
            g.setColor(new Color(0, 0, 0, 196));
            g.fillRect(bounds.x + mark_w * 2 / 4, bounds.y,
                    mark_w / 4, bounds.height);
            g.setColor(follow? new Color(0, 210, 0, 196) :
                    new Color(210, 0, 0, 196));
            g.fillRect(bounds.x + mark_w * 3 / 4, bounds.y,
                    mark_w / 4, bounds.height);
            g.setColor(new Color(210, 210, 210, 196));
            g.fillRect(bounds.x + mark_w, bounds.y, bounds.width - mark_w,
                    bounds.height);
            Font oldFont = g.getFont();
            g.setFont(new Font("Dialog", Font.BOLD, 14));
            g.setColor(Color.black);
            g.drawString(name, bounds.x + mark_w + 10,
                    bounds.y + bounds.height / 2 + 6);
            g.setFont(oldFont);
            mark = false;
            boolean slip = false;
            double dchange = 0.;
            if (bounds.contains(mouse_point)) {
                if (mouse_point.x < bounds.x + mark_w / 4) {
                    if (MouseTyped(1)) {
                        active = name;
                        mark = true;
                        follow = false;
                    }
                } else if (mouse_point.x < bounds.x + mark_w * 2 / 4) {
                    if (MouseTyped(1)) {
                        active = name;
                        for (MultiSlider slider : slaveSliders)
                            slider.mark = true;
                        morph = mouse_point.y < bounds.y + bounds.height / 2 ?
                                1 : -1;
                        timer = total_time;
                        follow = false;
                    }
                } else if (mouse_point.x < bounds.x + mark_w * 3 / 4) {
                    if (MouseTyped(1)) {
                        active = name;
                        for (MultiSlider slider : slaveSliders)
                            slider.val = slider.orig_val;
                    }
                } else if (mouse_point.x < bounds.x + mark_w) {
                    if (MouseTyped(1)) {
                        active = name;
                        follow = !follow;
                    }
                } else {
                    if (MouseTyped(1)) {
                        active = active == name ? "" : name;
                    }
                    if (active.equals(name)) {
                        slip = true;                       
                        int ccx = bounds.x + (bounds.width + mark_w) / 2;
                        int ccy = bounds.y + bounds.height / 2;
                        RecomputeMousePoint();
                        g.drawLine(bounds.x + mark_w, ccy,
                                bounds.x + bounds.width, ccy);
                        g.drawLine(ccx, bounds.y,
                                ccx, bounds.y + bounds.height);
                        double ddx = mouse_point.x - ccx;
                        double ddy = mouse_point.y - ccy;
                        double dd = frame_time /
                                Math.sqrt(ddx * ddx + ddy * ddy + 1);
                        ddx *= Math.max(0., 1 - 2 * dd);
                        ddy *= Math.max(0., 1 - 20 * dd);
                        if (!slippery) {
                            slippery = true;
                            ddx = ddy = 0.;
                        }
                        MouseMove(ccx + (int)ddx, ccy + (int)ddy);
                        vchange *= Math.exp(-2 * ddy / bounds.width);
                        vchange = Math.min(max_rate,
                                Math.max(min_rate, vchange));
                        dchange = vchange * ddx;
                    }
                }      
            }
            slippery = slip;
            for (MultiSlider slider : lonerSliders) slider.Slide();
            for (MultiSlider slider : slaveSliders) {
                slider.Slide();
                if (slider.mark) {
                    if (mark) {
                        slider.SetVal(slider.orig_val +
                                (2 * Math.random() - 1) *
                                        (slider.base_val - slider.orig_val));
                    } else {
                        if (total_time < timer + 0.8) {
                            slider.SetVal(slider.base_val + slider.rand_val);
                        } else if (total_time < timer + 1.) {
                            slider.SetVal(slider.base_val);
                        } else {
                            slider.SetVal(slider.val +
                                    dchange * slider.rand_val);
                            if (dchange != 0.) slider.base_val = slider.val;
                        }
                    }
                }
            }
            if (slaveSliders.size() > 0) mark = false;
        }
    }
    
    public class MultiSlider {
        public String name;
        public Rectangle bounds;
        public double min_val, val, max_val;
        public double orig_val, base_val, rand_val;
        public boolean markable, mark;
        public ArrayList<MultiSlider> slaveSliders;
        public final int mark_w = 20;
        public final int val_w = 140;
        
        public MultiSlider(String name_, Rectangle bounds_,
                double min_val_, double val_, double max_val_,
                boolean markable_) {
            name = name_;
            bounds = bounds_;
            min_val = min_val_;
            max_val = max_val_;
            markable = markable_;
            SetVal(val_);
            orig_val = base_val = rand_val = val;
            active = "";
            CancelTextArea();
            mark = false;
            rand_val = 1.;
            slaveSliders = new ArrayList<>();
        }
        
        public boolean IsActive() {
            return active.equals(name) || active.equals(name + "_txt");
        }
        
        public void SetVal(double val_) {
            val = Math.min(max_val, Math.max(min_val, val_));
        }

        public void Slide() {
            if (multi_entered && active.equals(name + "_txt")) ApplyText();
            Graphics2D g = graphics;
            int x0 = bounds.x;
            int x1 = x0 + mark_w;
            int x4 = x0 + bounds.width;
            int x3 = x4 - val_w;
            int x2 = x1 + (int)((x3 - x1) * (val - min_val) /
                    (max_val - min_val));
            g.setColor(mark? new Color(0, 210, 0, 196) :
                    new Color(210, 0, 0, 196));
            if (markable) g.fillRect(x0, bounds.y, x1 - x0, bounds.height);
            g.setColor(new Color(210, 210, 210, 196));
            g.fillRect(x1, bounds.y, x2 - x1, bounds.height);
            g.fillRect(x3, bounds.y, x4 - x3, bounds.height);
            g.setColor(new Color(150, 150, 150, 196));
            g.fillRect(x2, bounds.y, x3 - x2, bounds.height);
            g.setColor(Color.black);
            g.drawLine(x2, bounds.y, x2, bounds.y + bounds.height);
            if (slaveSliders.size() > 0) {
                int xh = x1 + (x3 - x1) / 3;
                g.drawLine(xh, bounds.y, xh, bounds.y + bounds.height);
                xh = x1 + (x3 - x1) * 2 / 3;
                g.drawLine(xh, bounds.y, xh, bounds.y + bounds.height);
            }
            g.setFont(new Font("Dialog", Font.BOLD, 14));
            g.drawString(name, x1 + 10, bounds.y + bounds.height / 2 + 4);
            boolean randomize = false;
            boolean markoni = false;
            if (!bounds.contains(mouse_point)) {
                if (active.equals(name)) {
                    active = "";
                } else if (active.equals(name + "_txt")) {
                    ApplyText();
                }
            } else {
                int mx = mouse_point.x;
                if (mx < x1) {
                    if (MouseTyped(1) && markable) {
                        mark = !mark;
                        markoni = true;
                    }
                } else if (mx < x3) {
                    if (MouseTyped(1)) {
                        randomize = active.equals(name);
                        active = active.equals(name)? "" : name;
                    }
                    if (active.equals(name)) {
                        double percent = Math.min(1., Math.max(0.,
                                (mx - x1 - 1.) / (x3 - x1 - 2.)));
                        SetVal(min_val + (max_val - min_val) * percent);
                        base_val = val;
                    }
                } else {
                    if (MouseTyped(1)) {
                        CancelTextArea();
                        active = active.equals(name)? "" : name + "_txt";
                    }
                }
            }
            String str = String.format("%.10f", val);
            g.setFont(new Font("Dialog", Font.BOLD, 14));
            g.drawString(str, x3 + 10, bounds.y + bounds.height / 2 + 4);
            if (active.equals(name + "_txt") && textArea == null) {
                SetTextArea(new Rectangle(x3 + 6, bounds.y, x4 - x3 - 10,
                        bounds.height), str, new Font("Dialog", Font.BOLD, 14));
            }
            for (MultiSlider slider : slaveSliders) {
                if (markoni) slider.mark = mark;
                if (randomize && slider.mark) slider.rand_val =
                        slider.min_val - slider.orig_val +
                        Math.random() * (slider.max_val - slider.min_val);
                slider.Slide();
                if (IsActive() && slider.mark) slider.SetVal(slider.orig_val +
                        val * slider.rand_val);
                slider.base_val = slider.val;
            }
        }
        
        void ApplyText() {
            SetVal(Double.parseDouble(text));
            base_val = val;
            active = "";
            multi_entered = text_enter = tab_enter = rtab_enter = false;
            text = "";
            CancelTextArea();
        }
        
    }
    
    public class TextRects {
    	public Font font;
        public FontMetrics fm;
        public String qtitle;
        public int id, ind, qid, qind;
        public int count, pcount, rcount;
        public int x, y, px, rx, ry, rw, rh;
        public Rectangle rect;
        public Color color;
        public boolean mouse_typed, inside_typed;
        public boolean next;
        
        public TextRects(Font font_) {
            font = font_;
            graphics.setFont(font);
            fm = graphics.getFontMetrics();
            rw = rh = fm.getHeight();
            color = Color.black;
            Clear();
        }
        
        public void Start(boolean mouse_typed_) {
            mouse_typed = mouse_typed_;
            id = 0;
            ind = -1;
            count = -1;
            inside_typed = false;
        }
        
        public void Clear() {
            Start(false);
            qtitle = null;
            qid = qind = -1;
            pcount = rcount = -1;
        }
        
        public void Newline() {
            ++id;
            ind = -1;
        }
    	
    	public String Act(String title_, Integer x_, Integer y_, Color color_,
                String value_,
                Integer rx_, Integer ry_, Integer rw_, Integer rh_) {
            ++ind;
            if (x_ == null) x_ = ind == 0 ? px : rx + rw + fm.getHeight() / 2;
            if (y_ == null) y_ = ind == 0 ? y + (int)(1.1 * rh) : y;
            if (color_ == null) color_ = color;
            if (rx_ == null) rx_ = x_ + fm.stringWidth(title_ + " ");
            if (ry_ == null) ry_ = y_;
            if (rw_ == null) rw_ = fm.stringWidth(value_ + "  ");
            if (rh_ == null) rh_ = rh;
            x = x_;
            y = y_;
            color = color_;
            rx = rx_;
            ry = ry_;
            rw = rw_;
            rh = rh_;
            if (ind == 0) px = x_;
            rect = new Rectangle(rx, ry, rw, rh);
            int h = fm.getHeight();
            graphics.setColor(color);
            graphics.drawString(title_, x, y + rh / 2 + h / 4);
            String value = value_;
            if (value == null) return value;
            ++count;
            if (id == 0 && ind == 0) count = 0;
            if ((id == qid) && (ind == qind)) {
            	if (tab_enter) next = true;
            	if (rtab_enter) rcount = pcount;
                if (text_enter || tab_enter || rtab_enter ||
                        (mouse_typed && !inside_typed)) {
                    if (!title_.equals(qtitle)) {
                        System.out.println(
                                "TextRects error: " + title_ + "!=" + qtitle);
                        System.exit(39);
                    }
                    text_enter = tab_enter = rtab_enter = false;
                    qid = qind = -1;
                    qtitle = null;
                    CancelTextArea();
                }
                value = text;
            } else if ((mouse_typed && rect.contains(mouse_point)) ||
                    next || (count == rcount)) {
            	next = false;
            	rcount = -1;
                qtitle = title_;
                qid = id;
                qind = ind;
                SetTextArea(rect, value, font);
                inside_typed = true;
            }
            pcount = count;
            graphics.setColor(Color.white);
            graphics.fillRect(rx, ry, rw, rh);
            graphics.setColor(Color.black);
            graphics.drawString(value, rx + h / 6, ry + rh / 2 + h / 4);
            return value;
    	}
        
        public String Act(String title_, String value_) {
            return Act(title_, null, null, null, value_,
                    null, null, null, null);
        }
        
    }
    
    public void SetTextArea(Rectangle bounds, String str, Font font) {
        text = str;
        text_enter = tab_enter = rtab_enter = false;
        textArea = new JTextArea(str);
        textArea.setBackground(Color.white);
        textArea.setBounds(bounds);
        if (font != null) textArea.setFont(font);
        drawPanel.add(textArea);
        textArea.addKeyListener(new KeyAdapter(){
            @Override
            public void keyTyped(KeyEvent evt){
                char c = evt.getKeyChar();
                text_enter = c == KeyEvent.VK_ENTER;
                tab_enter = (c == KeyEvent.VK_TAB) &&
                        (evt.getModifiersEx() <= 0);
                rtab_enter = (c == KeyEvent.VK_TAB) &&
                        (evt.getModifiersEx() > 0);
                if (text_enter || tab_enter || rtab_enter) CancelTextArea();
            }
        });
        textArea.requestFocus();
        textArea.selectAll();
    }
    
    public void CancelTextArea() {
        if (textArea == null) return;
        keyless = 7;
        textArea.removeAll();
        textArea = null;
        drawPanel.removeAll();
        FrameListen();
        multi_entered = true;
    }
    
    public boolean MultiEntered() {
        boolean h = multi_entered;
        multi_entered = false;
        return h;
    }
    
    public static double Angle(double x, double y) {
        double a = 0.;
        if (Math.abs(x) > Math.abs(y)) {
            a = Math.atan(y / x);
            if (x < 0.) a += Math.PI;
        } else if (y != 0) {
            a = 0.5 * Math.PI - Math.atan(x / y);
            if (y < 0) a -= Math.PI;
        }
        return a;
    }

    public static BufferedImage DeepCopy(BufferedImage bi) {
        ColorModel cm = bi.getColorModel();
        boolean isAlphaPremultiplied = cm.isAlphaPremultiplied();
        WritableRaster raster = bi.copyData(bi.getRaster().
                createCompatibleWritableRaster());
        return new BufferedImage(cm, raster, isAlphaPremultiplied, null);
    }
    
    public static String Serialize(Object obj) {
        String str = null;
        try {
            ByteArrayOutputStream bo = new ByteArrayOutputStream();
            ObjectOutputStream so = new ObjectOutputStream(bo);
            so.writeObject(obj);
            so.flush();
            // This encoding induces a bijection between byte[] and
            //   String (unlike UTF-8)
            str = bo.toString("ISO-8859-1");
        } catch (Exception ex) { Exit(ex); }
        return str;
    }
    
    public static <T> T Deserialize(String str, Class<T> cls) {
        T obj = null;
        try {
            // This encoding induces a bijection between byte[] and
            //   String (unlike UTF-8)
            byte b[] = str.getBytes("ISO-8859-1"); 
            ByteArrayInputStream bi = new ByteArrayInputStream(b);
            ObjectInputStream si = new ObjectInputStream(bi);
            obj = cls.cast(si.readObject());
        } catch (Exception ex) { Exit(ex); }
        return obj;
    }
        
    public static String SU(String[] sd) {
        String su = "";
        for (String s : sd) {
            su += "(" + s + ")";
        }
        return su;
    }
    
    public static String[] SD(String su) {
        ArrayList<String> al = new ArrayList<>();
        int j = 0;
        int k = -1;
        for (int i = 0; i < su.length(); ++i) {
            char c = su.charAt(i);
            if (c == '(') {
                ++j;
            } else if (c == ')') {
                --j;
            }
            if (j == 0) {
                al.add(su.substring(k + 2, i));
                k = i;
            }
        }
        String[] sd = new String[al.size()];
        sd = al.toArray(sd);
        return sd;
    }
    
    public static void WriteString(File file, String path, String str) {
        if (file == null) file = new File(CFN(path));
        if (file.getParentFile() != null) file.getParentFile().mkdirs();
        Writer writer = null;
        try {
            writer = new FileWriter(file);
        } catch (IOException ex) { Exit(ex); }
        try {
            writer.write(str);
        } catch (IOException ex) { Exit(ex); }
        try {
            writer.close();
        } catch (IOException ex) { Exit(ex); }
    }
    
    public static String ReadString(File file, String path) {
        if (file == null) file = new File(CFN(path));
        if (!file.exists()) return null;
        FileInputStream fileInputStream = null;
        try { fileInputStream = new FileInputStream(file);
        } catch (FileNotFoundException ex) { Exit(ex); }
        byte[] fileContent = new byte[(int) file.length()];
        try { fileInputStream.read(fileContent);
        } catch (IOException ex) { Exit(ex); }
        try { fileInputStream.close();
        } catch (IOException ex) { Exit(ex); }
        return new String(fileContent);
    }
    
    public static void RemoveOneColor(BufferedImage im, int col) {
        for (int j = 0; j < im.getHeight(); ++j) {
            for (int i = 0; i < im.getWidth(); ++i) {
                if (im.getRGB(i, j) == col) {
                    im.setRGB(i, j, col ^ 1);                }
            }
        }
    }
    
    public static void ChangeOneColor(BufferedImage im, int col, int new_col,
            Rectangle rect) {
        for (int j = Math.max(0, rect.y); j < Math.min(im.getHeight(),
                rect.y + rect.height); ++j) {
            for (int i = Math.max(0, rect.x); i < Math.min(im.getWidth(),
                    rect.x + rect.width); ++i) {
                if (im.getRGB(i, j) == col) {
                    im.setRGB(i, j, new_col);                
                }
            }
        }
    }
    
    public static int blend(int a, int b, double u) {
        int f0 = a & 0xff;
        int g0 = b & 0xff;
        int f1 = a & 0xff00;
        int g1 = b & 0xff00;
        int f2 = a & 0xff0000;
        int g2 = b & 0xff0000;
        int f3 = a >>> 24;
        int g3 = b >>> 24;
        return (int)(f0 + u * (g0 - f0)) +
                (((int)(f1 + u * (g1 - f1))) & 0xff00) +
                (((int)(f2 + u * (g2 - f2))) & 0xff0000) +
                (((int)(f3 + u * (g3 - f3))) << 24);
    }
    
    public static BufferedImage ColorImage(BufferedImage bi, int c) {
        BufferedImage out = Animator.DeepCopy(bi);
        double z = (c >>> 24) / 255.;
        for (int j = 0; j < out.getHeight(); ++j) {
            for (int i = 0; i < out.getWidth(); ++i) {
                int a = out.getRGB(i, j);
                if ((a >>> 24) == 0) {
                    continue;
                }
                int blue = (int)((a & 0xff) * (1 - z) + (c & 0xff) * z);
                int green = (int)(((a >>> 8) & 0xff) * (1 - z) +
                        ((c >>> 8) & 0xff) * z);
                int red = (int)(((a >>> 16) & 0xff) * (1 - z) +
                        ((c >>> 16) & 0xff) * z);
                out.setRGB(i, j, blue + (green << 8) + (red << 16) +
                        0xff000000);
            }
        }
        return out;
    }
    
    public static BufferedImage SemiTransparent(BufferedImage bi, int semi) {
        BufferedImage out = Animator.DeepCopy(bi);
        int sem = 0xffffff + (semi << 24);
        for (int j = 0; j < out.getHeight(); ++j) {
            for (int i = 0; i < out.getWidth(); ++i) {
                out.setRGB(i, j, out.getRGB(i, j) & sem);
            }
        }
        return out;
    }
    
    public static BufferedImage GradedSemiTransparent(
            BufferedImage bi, double thickness, double gamma) {
        BufferedImage out = Animator.DeepCopy(bi);
        int m = (Math.min(out.getWidth(), out.getHeight()) + 1) >> 1;
        double[] fac = new double[m];
        for (int k = 0; k < m; ++k)
            fac[k] = Math.pow(Math.min(1., (k + 1.) / (m * thickness)), gamma);
        for (int j = 0; j < out.getHeight(); ++j) {
            for (int i = 0; i < out.getWidth(); ++i) {
                int k = Math.min(Math.min(i, out.getWidth() - 1 - i),
                        Math.min(j, out.getHeight() - 1 - j));
                int argb = out.getRGB(i, j);
                out.setRGB(i, j, (argb & 0xffffff) + 
                        (((int)((argb >>> 24) * fac[k] + 0.5)) << 24));
            }
        }
        return out;
    }
    
    public static boolean isAsciiP(String str) {
        if (str == null) return false;
        for (int i = 0; i < str.length(); i++) {
            char ch = str.charAt(i);
            if (ch < 32 || ch >= 127) return false;
        }
        return true;
    }
    
    static long myrand;
    public static double MyRand() {
        myrand += System.currentTimeMillis();
        myrand *= Long.parseLong("635a036fb31d7365", 16);
        return myrand / (2. * Long.MAX_VALUE) + 0.5;
    }

}
